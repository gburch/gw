#!/bin/bash

branch_name=$(git symbolic-ref HEAD 2>/dev/null)
short_name=$(echo "$branch_name" | sed -e 's/refs\/heads\/\(.*\)/\1/')

case "$branch_name" in
*changes/*)
    very_short_name=$(echo "$branch_name" | sed -e 's/refs\/heads\/changes\/\([^\/]*\).*/\1/')
    ;;
*bugs/*)
    very_short_name=$(echo "$branch_name" | sed -e 's/refs\/heads\/bugs\/\([^\/]*\)/\1/')
    ;;
*topics/*)
    very_short_name=$(echo "$branch_name" | sed -e 's/refs\/heads\/topics\/\([^\/]*\)/\1/')
    ;;
esac


case $1 in
install)
  pushd $(dirname "${0}") > /dev/null
  basedir=$(pwd -L)
  # Use "pwd -P" for the path without links. man bash for more info.
  popd > /dev/null
  ln -s $basedir/gw /usr/bin/gw
  ;;
  topic)
    if git branch | grep ^..topics/$2>/dev/null 2>&1
    then
      echo "Feature $2 already exists. Use proj change <name> to modify"
      exit 1;
    fi

    #git remote update origin

    if git branch -a | grep ^..origin/topics/$2>/dev/null 2>&1
    then
      echo "Feature $2 already exists. Use proj change <name> to modify"
      exit 1;
    fi

    git branch topics/$2 master
    git co topics/$2
    ;;
  bug)
    git branch bugs/$2 master
    git co bugs/$2
    ;;
switch)
  local_branches=$(git branch)
  remote_branches=$(git branch -r)
  all_branches=$(git branch -a)

  #if there is a topic switch to that
  has_branch=$(echo "$all_branches" | grep "topics/$2")

  if [ -n "$has_branch" ]
  then
    git checkout topics/$2
    exit 0
  else
    echo "Branch not found, use gw list topics to see a list of topic branches"
  fi
  #if there is a bug switch to that
  #if there is a change switch to that
  ;;
publish)
  #Publish a topic branch right away, rather than waiting for a change
  
  if git branch -r | grep "^  origin/$short_name" >> /dev/null
  then
    echo "Topic branch already published"
    exit 1;
  fi

  if git branch -a --merged master | grep "^[\* ] $short_name" >> /dev/null
  then
    git push -u origin $short_name
  else
    echo "Pending changes, use gw change $short_name && git merge $short_name && gw review"
    echo "After you have resolved this you will also want to run gw reset $short_name to return"
    echo "$short_name back to its remote state"
  fi
  ;;
reset)
  if git branch -r | grep "^  origin/$short_name" >> /dev/null
  then
    git reset remotes/origin/$short_name
  else
    git reset remotes/origin/master
  fi
  ;;
show)
  if [ -n $2 ]
  then
    commit=$2
  fi
  fetch_id=$(git log $commit | grep -m 1 "Change-Id" | sed -e "s/^.*Change-Id: \(.*\)$/\1/")
  #todo fix disgusting yet awesome code
#  fetch_id="Ib0fc89983007e531897854e3ece3d19e7b4b71a0"

  id=$(curl -vs -H "Content-Type: application/json; charset=UTF-8" -H "Accept: application/json"\
  -X POST -d '{"jsonrpc":"2.0","method":"allQueryNext","params":["'$fetch_id'","z",25],"id":3}'\
  http://10.137.8.210:8080/gerrit/rpc/ChangeListService 2>&1 | sed -e 's/[{}]/''/g' | awk -v k="text" '{n=split($0,a,","); for (i=1; i<=n; i++) print a[i]}' |\
  grep "\"changes\":\[\"id\":\"id\":" | sed "s/\"changes\":\[\"id\":\"id\":\(.*\)/\1/")
  
  if [ -n "$id" ]
  then
    echo "You can view your last change here: http://10.137.8.210:8080/$id"
  else
    echo "Change-Id not found in gerrit, are you sure you have submitted it? Or maybe you want a previous commit. Use gw show <hash> to get the url for a specific commit"
  fi

  ;;
review)
#get change url
#grep "^remote:.*\(http://.*\)" test.txt | sed -e "s/.*\(http:\/\/.*\)/\1/"
  case "$branch_name" in
    *refs/heads/changes/*)
      #TODO: refactor into function since this is done in a couple of places, and in different ways
      echo "topic $branch_name";
      if git branch -r | grep origin/topics/$very_short_name>/dev/null 2>&1
      then
        echo "Remote branch already exists, submitting changes for review"
      else
        echo "No remote branch for $very_short_name, creating one..."
        git symbolic-ref HEAD "refs/heads/topics/$very_short_name"
        git push -u origin topics/$very_short_name
        git symbolic-ref HEAD $branch_name
#       git push origin remotes/origin/master:origin/topics/$very_short_name
      fi

      echo "Submititng changes for review"

      git push origin HEAD:refs/for/topics/$very_short_name
      ;;
    *refs/heads/topics*)
       if [[ "$2" == "final"  ]]
       then
         git rebase master -i
       else
        echo "It is bad practice to submit changes from a public topic branch, it leads to changes that are dependent."
        echo "To resolve this please run proj change <name> && git merge $short_name && proj review"
      fi
      ;;
    *refs/heads/bugs/*)
      
      git push origin HEAD:refs/for/master
      ;;
  esac
  ;;
clean)
  echo "Deleting bug branches that are merged with master"
  git remote update
  git remote prune origin
  git symbolic-ref HEAD "refs/heads/master"
  git branch -d $( git branch --merged | grep -v '^\*' | grep -v 'master' | grep "^  bugs/")
    
  git for-each-ref --format='%(refname)' refs/heads/topics/ | while read branch; do
    git rev-parse --quiet --verify "$branch" > /dev/null || continue
    echo "checking $branch"
    topic_name=$(echo "$branch" | sed -e 's/refs\/heads\/topics\/\([^\/]*\).*/\1/')
    echo "Topic: $topic_name"

    echo "merged branches:"
    git branch -d $( git branch --merged $branch | grep "^  changes/$topic_name")
    anyChanges=$(git rev-parse --branches=changes/$topic_name/)
    if [ -n "$anyChanges" ]
    then
      echo "There are unmerged changes skipping $topic_name"
      continue
    else
      echo "Topic branch that is merged with no pending changes, deleting..."
      remote=$(git branch -r | grep "^  topics/$topic_name")
      if [ -n "$remote" ]
      then
        echo"Deleting remote branch..."
        git push origin :topics/$topic_name
      fi
      git branch -d topics/$topic_name
    fi
  done
  ;; 
prototype)
  echo "Updating remotes"
  git remote update
  echo "Pruning remote branches"
  git remote prune origin
  echo "Checking out master"
  git co origin/master
  git branch -D prototype
  echo "Creating prototype branch"
  git co -b prototype
  echo "Starting Merge..."
  git for-each-ref --shell \
    --format='echo "Merging %(refname)" && git merge %(refname)' \
    refs/remotes/origin/features/ | sh
  ;;
convert)
  case "$2" in
    topic)
     if [[ "$branch_name" == *refs/heads/topics/* ]]
     then
         echo "Your current branch is already a topic branch";
     else
        git co -b topics/$very_short_name
     fi
      ;;
    bug)
     if [[ "$branch_name" == *refs/heads/bugs/* ]]
     then
         echo "Your current branch is already a bug branch";
     else
         git co -b bugs/$very_short_name
     fi
      ;;
    sandbox)
      ;;
  esac
  ;;
change)
  echo "Creating change $2 based off of $very_short_name"
  git branch changes/$very_short_name/$2 topics/$very_short_name
  git co changes/$very_short_name/$2
  ;;
list)
  if [ -n "$2" ]
  then
    case "$2" in
    all)
      #TODO Don't rely on origin being the name of the remote

      echo "Local Topics"
      git branch | grep "^[\* ] topics/"
      echo "Remote Topics"
      git branch -r | grep "^  origin/topic/"
      echo "Bugs"
      git branch | grep "^[\* ] bugs/"
      echo "Changes"
      git branch | grep "^[\* ] changes/"
      ;;
    topics)
      git branch | grep "^[\* ] topics/"
      ;;
    changes)
      git branch | grep "^[\* ] changes/"
      ;;
    bugs)
      git branch | grep "^[\* ] bugs/"
      ;;
    *)
      #todo use basename $0
        echo "Unrecognized switch, try gw list [all,topics,changes,bugs]"
      ;;
  esac
  else
    case "$branch_name" in
    *changes/*)
      git branch | grep "^  changes/$very_short_name"
      ;;
    *topics/*)
      git branch | grep "^  changes/$very_short_name"
      ;;
    esac
  fi
  ;;
  
*)
   echo "That option is not recognized"
   ;;
esac

#VN=$(git describe --abbrev=7 HEAD 2>/dev/null)  
#
#git update-index -q --refresh  
#CHANGED=$(git diff-index --name-only HEAD --)  
#if [ ! -z $CHANGED ];  
#    then VN="$VN-mod"   
#fi
